<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Tower Defense</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
        }
        .font-orbitron {
            font-family: 'Orbitron', sans-serif;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: #1f2937; /* bg-gray-800 */
            border: 1px solid #4b5563; /* border-gray-600 */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .modal.flex {
            display: flex;
        }
        .progress-bar-container {
            background-color: #374151; /* bg-gray-700 */
            border-radius: 9999px;
            overflow: hidden;
            border: 1px solid #4b5563; /* border-gray-600 */
        }
        .progress-bar {
            background-color: #34d399; /* bg-emerald-500 */
            height: 100%;
            transition: width 0.3s ease-in-out;
        }
        .tooltip {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .has-tooltip:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        .perk-button:disabled {
            background-color: #4b5563;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .perk-locked {
             background-color: #374151;
             opacity: 0.6;
        }
        .tower-button:disabled {
            filter: grayscale(80%);
            cursor: not-allowed;
            opacity: 0.6;
        }
        #top-ui, #bottom-ui, #center-screen-controls {
            z-index: 50;
        }
        .weapon-card {
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .weapon-card.selected {
            transform: translateY(-5px);
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.7);
            border-color: #3b82f6;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center h-screen">

    <div id="game-wrapper" class="relative w-full h-full max-w-7xl max-h-[800px] aspect-[16/9] shadow-2xl bg-black">
        <canvas id="game-canvas"></canvas>

        <!-- TOP UI -->
        <div id="top-ui" class="absolute top-0 left-0 right-0 p-4 flex justify-between pointer-events-none text-shadow">
            <!-- Top Left - Level Stats -->
            <div class="bg-gray-900/70 p-3 rounded-lg border border-gray-700 space-y-2">
                 <div class="flex items-center space-x-3">
                    <button id="pause-button" class="bg-yellow-600 hover:bg-yellow-700 rounded-full h-8 w-8 flex items-center justify-center pointer-events-auto text-gray-900">
                        <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6" />
                        </svg>
                         <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 hidden" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <div id="tower-count" class="font-orbitron text-lg">Towers: 0/6</div>
                </div>
                <div class="flex items-center space-x-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-red-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd" /></svg>
                    <span id="fortress-health" class="font-orbitron text-lg">100/100</span>
                </div>
                <div id="wave-info" class="font-orbitron text-lg">Wave: 0/2</div>
                <div class="flex items-center space-x-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-yellow-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v.01" /></svg>
                    <span id="coins" class="font-orbitron text-lg">350</span>
                </div>
            </div>

            <!-- Top Right - Persistent Stats -->
            <div class="bg-gray-900/70 p-3 rounded-lg border border-gray-700 space-y-2 text-right pointer-events-auto">
                <div class="font-orbitron text-lg">Player Level: <span id="player-level">1</span></div>
                <div class="w-48">
                    <div class="progress-bar-container h-4">
                        <div id="xp-bar" class="progress-bar" style="width: 0%;"></div>
                    </div>
                    <div id="xp-text" class="text-xs text-center mt-1">0 / 100 XP</div>
                </div>
                 <button id="perks-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-1 px-3 rounded-full inline-flex items-center space-x-2 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M5 4a2 2 0 012-2h6a2 2 0 012 2v14l-5-2.5L5 18V4z" /></svg>
                    <span>Gems: <span id="gems">0</span></span>
                </button>
            </div>
        </div>

        <!-- BOTTOM UI -->
        <div id="bottom-ui" class="absolute bottom-0 left-0 right-0 p-4 flex justify-between items-end pointer-events-none">
             <!-- Player Health -->
            <div id="player-health-ui" class="bg-gray-900/70 p-3 rounded-lg border border-gray-700 space-y-2">
                <p class="font-orbitron text-lg">Knight Health</p>
                <div class="w-48">
                    <div class="progress-bar-container h-4">
                        <div id="player-health-bar" class="progress-bar bg-red-500" style="width: 100%;"></div>
                    </div>
                    <div id="player-health-text" class="text-xs text-center mt-1">100 / 100</div>
                </div>
            </div>
            
            <!-- Tower Build/Upgrade Bar -->
            <div class="flex-grow flex justify-center">
                <div id="tower-build-bar" class="bg-gray-900/70 p-3 rounded-lg border border-gray-700 flex space-x-4 pointer-events-auto">
                    <!-- Tower buttons will be dynamically added here -->
                </div>
                <div id="tower-upgrade-bar" class="hidden bg-gray-900/70 p-3 rounded-lg border border-gray-700 flex items-center space-x-4 pointer-events-auto">
                    <!-- Upgrade info here -->
                </div>
            </div>
             <!-- Empty div to balance flexbox -->
            <div class="w-56"></div>
        </div>
        
        <!-- Center Screen Button -->
        <div id="center-screen-controls" class="absolute inset-0 flex items-center justify-center pointer-events-none">
             <button id="start-wave-button" class="bg-green-600 hover:bg-green-700 text-white font-orbitron text-2xl py-4 px-8 rounded-lg pointer-events-auto shadow-lg transform hover:scale-105 transition">READY</button>
        </div>


        <!-- MODALS -->
         <!-- Weapon Select Modal -->
        <div id="weapon-select-modal" class="modal">
            <div class="modal-content p-8 max-w-3xl w-full text-center">
                <h2 class="text-3xl font-orbitron mb-4">Choose Your Weapon</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6" id="weapon-selection-grid">
                    <!-- Weapon cards will be injected here -->
                </div>
                <button id="confirm-weapon-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-xl transition" disabled>Select Weapon</button>
            </div>
        </div>

        <!-- Level Start Modal -->
        <div id="level-start-modal" class="modal">
            <div class="modal-content p-8 max-w-md w-full text-center">
                <h2 class="text-3xl font-orbitron mb-2">Level <span id="start-modal-level">1</span></h2>
                <div class="text-gray-400 mb-6">Prepare your defenses!</div>
                <div class="bg-gray-700/50 p-4 rounded-lg space-y-3 mb-6">
                    <p class="text-lg">Starting Coins: <span id="start-modal-coins" class="text-yellow-400 font-bold">350</span></p>
                    <p class="text-lg">Enemy Types:</p>
                    <div id="start-modal-enemies" class="flex justify-center flex-wrap gap-4 text-sm text-gray-300">
                        <!-- Enemy types shown here -->
                    </div>
                </div>
                <button id="start-level-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-xl transition">Start Level</button>
            </div>
        </div>

        <!-- Level Complete Modal -->
        <div id="level-complete-modal" class="modal">
            <div class="modal-content p-8 max-w-md w-full text-center">
                <h2 class="text-3xl font-orbitron text-green-400 mb-2">Level Complete!</h2>
                <div class="bg-gray-700/50 p-4 rounded-lg space-y-2 mb-6 text-left">
                    <p>Base XP: <span id="complete-modal-base-xp" class="text-white font-bold float-right"></span></p>
                    <p>Time Bonus: <span id="complete-modal-time-bonus" class="text-white font-bold float-right"></span></p>
                     <p>Towers Remaining: <span id="complete-modal-tower-bonus" class="text-white font-bold float-right"></span></p>
                    <p class="border-t border-gray-600 my-2"></p>
                    <p class="text-lg">Total XP Earned: <span id="complete-modal-total-xp" class="text-green-400 font-bold float-right"></span></p>
                </div>
                <div id="level-up-alert" class="hidden my-4 p-3 bg-purple-500/30 border border-purple-500 rounded-lg">
                    <p class="font-bold text-lg">LEVEL UP!</p>
                    <p>You earned <span id="gem-reward">1</span> Gem!</p>
                </div>
                <button id="next-level-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-xl transition">Next Level</button>
            </div>
        </div>
        
        <!-- Level Failed Modal -->
        <div id="level-failed-modal" class="modal">
            <div class="modal-content p-8 max-w-md w-full text-center">
                <h2 class="text-3xl font-orbitron text-red-500 mb-4">Game Over!</h2>
                <p class="text-gray-400 mb-6">Your knight has fallen or the fortress has been destroyed.</p>
                <button id="retry-level-button" class="w-full bg-yellow-600 hover:bg-yellow-700 text-gray-900 font-bold py-3 px-4 rounded-lg text-xl transition">Retry Level</button>
            </div>
        </div>
        
        <!-- Perks Modal -->
        <div id="perks-modal" class="modal">
            <div class="modal-content p-6 max-w-6xl w-full max-h-[90vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4 sticky top-0 bg-gray-800 py-2">
                     <h2 class="text-3xl font-orbitron">Perks</h2>
                     <button id="close-perks-button" class="text-gray-400 hover:text-white text-3xl leading-none">&times;</button>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-x-6 gap-y-8">
                     <!-- Player Perks -->
                    <div>
                        <h3 class="text-xl font-orbitron mb-3 text-green-400">Player Perks</h3>
                        <div id="player-perks-list" class="space-y-3">
                            <!-- Perks dynamically loaded here -->
                        </div>
                    </div>
                    <!-- Global Perks -->
                    <div>
                        <h3 class="text-xl font-orbitron mb-3 text-cyan-400 flex items-center">
                            Global Perks 
                            <span id="global-perks-lock" class="ml-2 text-sm text-red-400">(Locked until Player Level 5)</span>
                        </h3>
                        <div id="global-perks-list" class="space-y-3">
                            <!-- Perks dynamically loaded here -->
                        </div>
                    </div>
                     <!-- Tower Perks -->
                    <div>
                        <h3 class="text-xl font-orbitron mb-3 text-orange-400 flex items-center">
                            Tower Perks
                             <span id="tower-perks-lock" class="ml-2 text-sm text-red-400">(Locked until Player Level 20)</span>
                        </h3>
                        <div id="tower-perks-list" class="space-y-3">
                            <!-- Perks dynamically loaded here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        // --- GAME SETUP ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // UI Elements
        const ui = {
            fortressHealth: document.getElementById('fortress-health'),
            waveInfo: document.getElementById('wave-info'),
            coins: document.getElementById('coins'),
            playerLevel: document.getElementById('player-level'),
            xpBar: document.getElementById('xp-bar'),
            xpText: document.getElementById('xp-text'),
            gems: document.getElementById('gems'),
            towerBuildBar: document.getElementById('tower-build-bar'),
            towerUpgradeBar: document.getElementById('tower-upgrade-bar'),
            startWaveButton: document.getElementById('start-wave-button'),
            playerHealthBar: document.getElementById('player-health-bar'),
            playerHealthText: document.getElementById('player-health-text'),
            towerCount: document.getElementById('tower-count'),
            pauseButton: document.getElementById('pause-button'),
            pauseIcon: document.getElementById('pause-icon'),
            playIcon: document.getElementById('play-icon'),
            modals: {
                levelStart: document.getElementById('level-start-modal'),
                levelComplete: document.getElementById('level-complete-modal'),
                levelFailed: document.getElementById('level-failed-modal'),
                perks: document.getElementById('perks-modal'),
                weaponSelect: document.getElementById('weapon-select-modal'),
            },
            levelUpAlert: document.getElementById('level-up-alert'),
            gemReward: document.getElementById('gem-reward'),
            playerPerksList: document.getElementById('player-perks-list'),
            globalPerksList: document.getElementById('global-perks-list'),
            towerPerksList: document.getElementById('tower-perks-list'),
            globalPerksLock: document.getElementById('global-perks-lock'),
            towerPerksLock: document.getElementById('tower-perks-lock'),
        };

        // --- GAME CONFIGURATION ---
        const TILE_SIZE = 40;
        let GRID_WIDTH, GRID_HEIGHT;

        const PLAYER_WEAPONS = {
            pistol: { name: 'Pistol', description: 'Balanced fire rate and damage.', damage: 8, fireRate: 20, range: 150, projectileSpeed: 7, projectileColor: '#eab308' },
            shotgun: { name: 'Shotgun', description: 'Fires multiple projectiles in a cone.', damage: 5, fireRate: 50, range: 100, projectileSpeed: 8, projectileColor: '#f97316', projectiles: 5, spread: 0.5 },
            rocket: { name: 'Rocket Launcher', description: 'Slow firing, high splash damage.', damage: 25, fireRate: 100, range: 200, projectileSpeed: 4, projectileColor: '#ef4444', splashRadius: 50 },
        };

        const TOWER_TYPES = {
            'turret': { name: 'Turret', cost: 100, color: '#3b82f6', health: 100, range: 120, damage: 10, fireRate: 30, projectileSpeed: 6, projectileColor: '#60a5fa', description: 'Basic single-target tower.' },
            'splash': { name: 'Splash', cost: 150, color: '#f97316', health: 120, range: 90, damage: 15, fireRate: 60, projectileSpeed: 4, splashRadius: 40, projectileColor: '#fb923c', description: 'Deals area damage.' },
            'sniper': { name: 'Sniper', cost: 250, color: '#8b5cf6', health: 80, range: 300, damage: 50, fireRate: 120, projectileSpeed: 15, projectileColor: '#a78bfa', description: 'Long range, high damage.' },
            'slow': { name: 'Slow', cost: 120, color: '#14b8a6', health: 100, range: 100, damage: 1, fireRate: 40, projectileSpeed: 5, slow: { amount: 0.5, duration: 120 }, projectileColor: '#2dd4bf', description: 'Slows enemies.'},
            'multi': { name: 'Multi-Shot', cost: 200, color: '#ec4899', health: 100, range: 110, damage: 7, fireRate: 45, projectileSpeed: 6, projectiles: 3, projectileColor: '#f472b6', description: 'Shoots 3 projectiles in a cone.'},
            'fire': { name: 'Fire', cost: 180, color: '#f59e0b', health: 150, range: 80, damage: 8, fireRate: 50, projectileSpeed: 5, dot: { damage: 8, duration: 240 }, projectileColor: '#facc15', description: 'Applies heavy damage over time.'},
            'missile': { name: 'Missile', cost: 350, color: '#6366f1', health: 200, range: 180, damage: 80, fireRate: 150, projectileSpeed: 3, splashRadius: 50, projectileColor: '#818cf8', description: 'High damage, splash.'},
            'healer': { name: 'Healer', cost: 175, color: '#22c55e', health: 120, range: 100, healAmount: 5, fireRate: 50, description: 'Heals nearby towers and player.'},
        };

        const ENEMY_TYPES = {
            'basic': { name: 'Basic', health: 50, speed: 1, coins: 15, color: '#ef4444', attack: 1 },
            'fast': { name: 'Fast', health: 40, speed: 2, coins: 10, color: '#fde047', attack: 1 },
            'tank': { name: 'Tank', health: 250, speed: 0.5, coins: 35, color: '#6b7280', attack: 5 },
        };
        
        const PERKS_CONFIG = {
            // Player Perks
            playerHealth: { name: 'Knight Health', type: 'player', maxLevel: 10, cost: 1, costIncrease: 1, effect: 25, unlockLevel: 1 },
            playerSpeed: { name: 'Knight Speed', type: 'player', maxLevel: 5, cost: 2, costIncrease: 1, effect: 0.1, unlockLevel: 1 },
            pickupRange: { name: 'Coin Pickup Range', type: 'player', maxLevel: 5, cost: 1, costIncrease: 0, effect: 10, unlockLevel: 1 },
            // Global Perks
            towerDamage: { name: 'Tower Damage', type: 'global', maxLevel: 10, cost: 1, costIncrease: 1, effect: 0.05, unlockLevel: 5 },
            towerHealth: { name: 'Tower Health', type: 'global', maxLevel: 10, cost: 1, costIncrease: 1, effect: 0.1, unlockLevel: 5 },
            towerRange: { name: 'Tower Range', type: 'global', maxLevel: 5, cost: 2, costIncrease: 1, effect: 0.05, unlockLevel: 5 },
            startingCoins: { name: 'Starting Coins', type: 'global', maxLevel: 10, cost: 1, costIncrease: 0, effect: 50, unlockLevel: 5 },
            // Tower Perks
            turretStartLevel: { name: 'Turret Start Lvl', type: 'tower', tower: 'turret', maxLevel: 5, cost: 2, costIncrease: 1, unlockLevel: 20 },
            splashStartLevel: { name: 'Splash Start Lvl', type: 'tower', tower: 'splash', maxLevel: 5, cost: 2, costIncrease: 1, unlockLevel: 20 },
        };
        
        // --- GAME STATE ---
        let gameState = {
            gameRunning: false,
            isPaused: false,
            currentLevel: 1,
            fortressHealth: 100,
            maxFortressHealth: 100,
            coins: 350,
            currentWave: 0,
            totalWaves: 2,
            maxTowers: 6,
            waveCountdown: -1,
            levelEnemyType: 'basic',
            towers: [],
            enemies: [],
            projectiles: [],
            effects: [],
            coinsOnGround: [],
            path: [],
            grid: [],
            selectedTowerType: null,
            selectedTower: null,
            mouse: { x: 0, y: 0 },
            levelStartTime: 0,
            player: null,
            keys: {},
            playerData: {
                level: 1,
                xp: 0,
                gems: 0,
                perks: {}
            }
        };

        // --- CLASSES ---
        class Player {
            constructor(x, y, weaponType) {
                this.x = x;
                this.y = y;
                this.baseSpeed = 2;
                this.maxHealth = 100 + getPerkEffect('playerHealth');
                this.health = this.maxHealth;
                this.weapon = JSON.parse(JSON.stringify(PLAYER_WEAPONS[weaponType]));
                this.target = null;
                this.fireCooldown = 0;
                this.pickupRange = 80 + getPerkEffect('pickupRange');
            }

            draw() {
                // Knight Body
                ctx.fillStyle = '#cbd5e1'; // silver
                ctx.beginPath();
                ctx.arc(this.x, this.y, TILE_SIZE / 2 - 8, 0, Math.PI * 2);
                ctx.fill();

                // Weapon Barrel
                if (this.target) {
                    const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle);
                    ctx.fillStyle = '#4b5563'; // gray
                    ctx.fillRect(TILE_SIZE / 2 - 10, -3, 15, 6);
                    ctx.restore();
                }

                 // Health bar
                const healthBarWidth = TILE_SIZE * 0.8;
                const healthBarHeight = 5;
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(this.x - healthBarWidth / 2, this.y + TILE_SIZE / 2 - 10, healthBarWidth, healthBarHeight);
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(this.x - healthBarWidth / 2, this.y + TILE_SIZE / 2 - 10, healthBarWidth * (this.health / this.maxHealth), healthBarHeight);
            }
            
            update() {
                // Movement
                let dx = 0;
                let dy = 0;
                const speed = this.baseSpeed * (1 + getPerkEffect('playerSpeed'));
                if (gameState.keys['w']) dy -= 1;
                if (gameState.keys['s']) dy += 1;
                if (gameState.keys['a']) dx -= 1;
                if (gameState.keys['d']) dx += 1;
                
                if (dx !== 0 || dy !== 0) {
                    const magnitude = Math.sqrt(dx * dx + dy * dy);
                    this.x += (dx / magnitude) * speed;
                    this.y += (dy / magnitude) * speed;
                }

                // Keep player in bounds
                this.x = Math.max(0, Math.min(canvas.width, this.x));
                this.y = Math.max(0, Math.min(canvas.height, this.y));

                // Shooting
                if (this.fireCooldown > 0) this.fireCooldown--;

                if (this.target && (this.dist(this.target) > this.weapon.range || this.target.health <= 0)) {
                    this.target = null;
                }
                if (!this.target) this.findEnemyTarget();
                
                if (this.target && this.fireCooldown <= 0) {
                    this.fire();
                    this.fireCooldown = this.weapon.fireRate;
                }
                
                // Coin Pickup
                gameState.coinsOnGround.forEach(coin => {
                    if (this.dist(coin) < this.pickupRange) {
                        coin.isAttracted = true;
                    }
                });
            }
            
            findEnemyTarget() {
                let closestEnemy = null;
                let minDistance = this.weapon.range;
                for (const enemy of gameState.enemies) {
                    const d = this.dist(enemy);
                    if (d < minDistance) {
                        minDistance = d;
                        closestEnemy = enemy;
                    }
                }
                this.target = closestEnemy;
            }

            fire() {
                const fireCount = this.weapon.projectiles || 1;
                const baseAngle = this.target ? Math.atan2(this.target.y - this.y, this.target.x - this.x) : 0;

                for (let i = 0; i < fireCount; i++) {
                    let angle = baseAngle;
                    if (this.weapon.spread) {
                        angle += (Math.random() - 0.5) * this.weapon.spread;
                    }
                    const p = new Projectile(this.x, this.y, this.target, 'player', 1, angle);
                    gameState.projectiles.push(p);
                }
            }

            dist(target) {
                return Math.sqrt(Math.pow(this.x - target.x, 2) + Math.pow(this.y - target.y, 2));
            }
        }
        
        class Tower {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.level = 1;
                this.config = JSON.parse(JSON.stringify(TOWER_TYPES[type]));
                this.target = null;
                this.fireCooldown = 0;
                
                const healthPerk = getPerkEffect('towerHealth');
                this.maxHealth = this.config.health * (1 + healthPerk);
                this.health = this.maxHealth;
            }

            draw() {
                // Selection circle
                if(gameState.selectedTower === this) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.getRange(), 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = this.config.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, TILE_SIZE / 2 - 5, 0, Math.PI * 2);
                ctx.fill();

                if (this.type === 'healer') {
                     ctx.fillStyle = 'white';
                     ctx.font = 'bold 20px sans-serif';
                     ctx.textAlign = 'center';
                     ctx.textBaseline = 'middle';
                     ctx.fillText('+', this.x, this.y);
                } else if (this.target) {
                    const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + Math.cos(angle) * (TILE_SIZE / 2), this.y + Math.sin(angle) * (TILE_SIZE / 2));
                    ctx.stroke();
                }
                
                // Health bar
                const healthBarWidth = TILE_SIZE * 0.8;
                const healthBarHeight = 5;
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(this.x - healthBarWidth / 2, this.y + TILE_SIZE / 2 - 5, healthBarWidth, healthBarHeight);
                ctx.fillStyle = '#10b981';
                ctx.fillRect(this.x - healthBarWidth / 2, this.y + TILE_SIZE / 2 - 5, healthBarWidth * (this.health / this.maxHealth), healthBarHeight);
                
                ctx.fillStyle = 'white';
                ctx.font = '12px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(this.level, this.x, this.y + 4);
            }
            
            update() {
                if (this.fireCooldown > 0) this.fireCooldown--;

                if (this.type === 'healer') {
                    if (!this.target || this.target.health <= 0 || this.target.health >= this.target.maxHealth) {
                        this.target = null;
                        this.findAllyTarget();
                    }
                } else {
                     if (this.target && (this.dist(this.target) > this.getRange() || this.target.health <= 0)) {
                        this.target = null;
                     }
                    if (!this.target) this.findEnemyTarget();
                }

                if (this.target && this.fireCooldown <= 0) {
                    this.fire();
                    this.fireCooldown = this.config.fireRate;
                }
            }

            findEnemyTarget() {
                let closestEnemy = null;
                let minDistance = this.getRange();
                for (const enemy of gameState.enemies) {
                    const d = this.dist(enemy);
                    if (d < minDistance) {
                        minDistance = d;
                        closestEnemy = enemy;
                    }
                }
                this.target = closestEnemy;
            }
            
            findAllyTarget() {
                let mostDamagedAlly = null;
                let lowestHealthPct = 1;
                // Check player first
                if (gameState.player && this.dist(gameState.player) < this.getRange()) {
                    const playerHealthPct = gameState.player.health / gameState.player.maxHealth;
                    if (playerHealthPct < lowestHealthPct) {
                        lowestHealthPct = playerHealthPct;
                        mostDamagedAlly = gameState.player;
                    }
                }
                // Then check towers
                for (const tower of gameState.towers) {
                    if (tower === this) continue;
                    const d = this.dist(tower);
                    const healthPct = tower.health / tower.maxHealth;
                    if (d < this.getRange() && healthPct < lowestHealthPct) {
                        lowestHealthPct = healthPct;
                        mostDamagedAlly = tower;
                    }
                }
                this.target = mostDamagedAlly;
            }

            fire() {
                if (this.type === 'healer') {
                    if(this.target) {
                        this.target.health = Math.min(this.target.maxHealth, this.target.health + this.config.healAmount);
                        gameState.effects.push(new HealEffect(this.target.x, this.target.y));
                    }
                } else if (this.type === 'multi') {
                    const baseAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                    const spread = 0.4; // Radians for the cone
                    for (let i = 0; i < this.config.projectiles; i++) {
                        const angle = baseAngle + (i - Math.floor(this.config.projectiles / 2)) * spread;
                        const p = new Projectile(this.x, this.y, this.target, this.type, this.level, angle);
                        gameState.projectiles.push(p);
                    }
                } else {
                    const fireCount = this.config.projectiles || 1;
                    for (let i = 0; i < fireCount; i++) {
                         const p = new Projectile(this.x, this.y, this.target, this.type, this.level);
                         gameState.projectiles.push(p);
                    }
                }
            }
            
            upgrade() {
                const cost = this.getUpgradeCost();
                if(gameState.coins >= cost) {
                    gameState.coins -= cost;
                    this.level++;
                    if (this.type === 'healer') {
                        this.config.healAmount *= 1.3;
                    } else {
                        this.config.damage *= 1.2;
                    }
                    this.config.range *= 1.05;
                    this.maxHealth *= 1.2;
                    this.health = this.maxHealth;
                    updateUI();
                    showTowerUpgradeUI(this);
                }
            }

            getUpgradeCost() {
                return Math.floor(this.config.cost * 0.8 * Math.pow(1.5, this.level -1));
            }
            
            getDamage() {
                if (this.type === 'healer') return 0;
                const damagePerk = getPerkEffect('towerDamage');
                return this.config.damage * (1 + damagePerk) * Math.pow(1.1, this.level - 1);
            }
            
            getRange() {
                const rangePerk = getPerkEffect('towerRange');
                return this.config.range * (1 + rangePerk);
            }

            dist(target) {
                return Math.sqrt(Math.pow(this.x - target.x, 2) + Math.pow(this.y - target.y, 2));
            }
        }
        
        class Enemy {
             constructor(type, isBoss = false, isMiniBoss = false) {
                this.type = type;
                this.config = ENEMY_TYPES[type];
                this.pathIndex = 0;
                this.x = gameState.path[0].x;
                this.y = gameState.path[0].y;
                this.isBoss = isBoss;
                this.isMiniBoss = isMiniBoss;
                this.health = this.config.health * Math.pow(1.15, gameState.currentLevel - 1);
                if(this.isBoss) {
                    this.health *= 5;
                }
                if(this.isMiniBoss) {
                    this.health *= 2.5;
                }
                this.maxHealth = this.health;
                this.speed = this.config.speed;
                this.slowTimer = 0;
                this.dotTimer = 0;
                this.dotDamage = 0;
            }

            draw() {
                ctx.save();
                ctx.fillStyle = this.slowTimer > 0 ? this.config.color + '80' : this.config.color;

                const radius = this.isBoss ? (TILE_SIZE / 2 - 4) : this.isMiniBoss ? (TILE_SIZE / 2 - 6) : (TILE_SIZE / 2 - 8);
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();

                if(this.isBoss) {
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                 if(this.isMiniBoss) {
                    ctx.strokeStyle = '#f97316';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                ctx.restore();

                if (this.dotTimer > 0) {
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y - 10, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                const healthBarWidth = TILE_SIZE * (this.isBoss ? 1.2 : this.isMiniBoss ? 1 : 0.8);
                const healthBarHeight = 5;
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(this.x - healthBarWidth / 2, this.y - TILE_SIZE / 2, healthBarWidth, healthBarHeight);
                ctx.fillStyle = '#10b981';
                ctx.fillRect(this.x - healthBarWidth / 2, this.y - TILE_SIZE / 2, healthBarWidth * (this.health / this.maxHealth), healthBarHeight);
            }
            
            update() {
                if (this.slowTimer > 0) this.slowTimer--;
                if (this.dotTimer > 0) {
                    this.dotTimer--;
                    if(this.dotTimer % 30 === 0) this.health -= this.dotDamage;
                }
                
                if (this.pathIndex < gameState.path.length - 1) {
                    const target = gameState.path[this.pathIndex + 1];
                    const angle = Math.atan2(target.y - this.y, target.x - this.x);
                    const currentSpeed = this.speed * (this.slowTimer > 0 ? 0.5 : 1);
                    this.x += Math.cos(angle) * currentSpeed;
                    this.y += Math.sin(angle) * currentSpeed;

                    const distToTarget = Math.sqrt(Math.pow(target.x - this.x, 2) + Math.pow(target.y - this.y, 2));
                    if (distToTarget < currentSpeed) {
                        this.pathIndex++;
                    }
                } else {
                    gameState.fortressHealth -= this.isBoss ? 25 : this.isMiniBoss ? 15 : 10;
                    this.health = 0; 
                    if (gameState.fortressHealth <= 0) {
                        gameState.fortressHealth = 0;
                        levelFailed();
                    }
                }
                
                // Attack towers
                gameState.towers.forEach(tower => {
                    if (Math.hypot(this.x - tower.x, this.y - tower.y) < TILE_SIZE * 0.8) {
                        tower.health -= this.config.attack / 60;
                    }
                });

                // Attack player
                if(gameState.player && Math.hypot(this.x - gameState.player.x, this.y - gameState.player.y) < TILE_SIZE * 0.8) {
                    gameState.player.health -= this.config.attack / 60;
                    if(gameState.player.health <= 0) levelFailed();
                }
            }
        }
        
        class Projectile {
            constructor(x, y, target, ownerType, level, angleOverride = null) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.ownerType = ownerType; // 'player' or a tower type
                this.level = level;
                
                this.config = ownerType === 'player' ? gameState.player.weapon : TOWER_TYPES[ownerType];
                const angle = angleOverride ?? Math.atan2(target.y - y, target.x - x);
                
                this.vx = Math.cos(angle) * this.config.projectileSpeed;
                this.vy = Math.sin(angle) * this.config.projectileSpeed;
            }

            draw() {
                ctx.fillStyle = this.config.projectileColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Check for off-screen
                if(this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.x = -100; // Mark for removal
                    return;
                }
                
                for (const enemy of gameState.enemies) {
                    const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                    if (dist < TILE_SIZE / 2) {
                        this.hit(enemy);
                        this.x = -100; // Mark for removal
                        return;
                    }
                }
            }
            
            hit(enemy) {
                 let totalDamage;
                 if(this.ownerType === 'player') {
                     totalDamage = this.config.damage;
                 } else {
                     const damagePerk = getPerkEffect('towerDamage');
                     const baseDamage = this.config.damage * Math.pow(1.2, this.level - 1);
                     totalDamage = baseDamage * (1 + damagePerk);
                 }
                 
                 enemy.health -= totalDamage;
                 
                 if(this.config.slow) enemy.slowTimer = this.config.slow.duration;
                 if(this.config.dot) {
                    enemy.dotTimer = this.config.dot.duration;
                    enemy.dotDamage = this.config.dot.damage;
                 }
                 
                 if (this.config.splashRadius) {
                    gameState.enemies.forEach(otherEnemy => {
                         if (otherEnemy !== enemy) {
                             if (Math.hypot(enemy.x - otherEnemy.x, enemy.y - otherEnemy.y) < this.config.splashRadius) {
                                 otherEnemy.health -= totalDamage / 2;
                             }
                         }
                    });
                 }
            }
        }
        
        class Coin {
            constructor(x, y, value) {
                this.x = x;
                this.y = y;
                this.value = value;
                this.isAttracted = false;
                this.life = 300; // 5 seconds
            }

            draw() {
                ctx.fillStyle = '#facc15';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#f59e0b';
                ctx.stroke();
            }

            update() {
                this.life--;
                if(this.isAttracted && gameState.player) {
                    const angle = Math.atan2(gameState.player.y - this.y, gameState.player.x - this.x);
                    this.x += Math.cos(angle) * 8;
                    this.y += Math.sin(angle) * 8;
                    
                    if(Math.hypot(this.x - gameState.player.x, this.y - gameState.player.y) < TILE_SIZE / 2) {
                        gameState.coins += this.value;
                        this.life = 0; // Mark for removal
                    }
                }
            }
        }
        
        class HealEffect {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.duration = 20;
                this.opacity = 1;
            }

            draw() {
                ctx.fillStyle = `rgba(34, 197, 94, ${this.opacity})`;
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('+', this.x, this.y - TILE_SIZE / 2);
            }

            update() {
                this.duration--;
                this.y -= 0.5;
                this.opacity = this.duration / 20;
            }
        }

        // --- GAME LOGIC ---
        function generatePath() {
            gameState.path = [];
            gameState.grid = Array(GRID_HEIGHT).fill(0).map(() => Array(GRID_WIDTH).fill(0));
            let currentX = 0, currentY = Math.floor(GRID_HEIGHT / 2), lastDir = 'right';
            const addPathSegment = (x, y) => {
                if (y >= 2 && y < GRID_HEIGHT - 2 && x >=0 && x < GRID_WIDTH) {
                    gameState.path.push({ x: x * TILE_SIZE + TILE_SIZE / 2, y: y * TILE_SIZE + TILE_SIZE / 2 });
                    gameState.grid[y][x] = 1;
                    return true;
                }
                return false;
            };
            addPathSegment(currentX, currentY);
            while (currentX < GRID_WIDTH - 2) {
                const dirs = [];
                if (lastDir !== 'left') dirs.push('right');
                if (lastDir !== 'down' && currentY > 2) dirs.push('up');
                if (lastDir !== 'up' && currentY < GRID_HEIGHT - 3) dirs.push('down');
                let nextDir = lastDir !== 'right' && Math.random() < 0.8 ? 'right' : dirs[Math.floor(Math.random() * dirs.length)] || 'right';
                const moveLength = Math.floor(Math.random() * 4) + 2;
                for (let i = 0; i < moveLength; i++) {
                    if (currentX >= GRID_WIDTH - 2) break;
                    if (nextDir === 'right') currentX++; else if (nextDir === 'up') currentY--; else if (nextDir === 'down') currentY++;
                    if (!addPathSegment(currentX, currentY)) {
                         if(nextDir === 'up') currentY++; else if(nextDir === 'down') currentY--; else if(nextDir === 'right') currentX--;
                         break;
                    }
                }
                lastDir = nextDir;
            }
            while (currentX < GRID_WIDTH - 1) {
                currentX++;
                addPathSegment(currentX, currentY);
            }
        }

        function spawnWave() {
            gameState.currentWave++;
            // Final Boss Wave
            if (gameState.currentWave === gameState.totalWaves) {
                let bossType = 'basic';
                if(gameState.currentLevel >= 5) bossType = 'tank';
                else if (gameState.currentLevel >= 3) bossType = 'fast';
                gameState.enemies.push(new Enemy(bossType, true, false));
                return;
            }
            // Mini-Boss Wave
            if (gameState.currentWave > 0 && gameState.currentWave < gameState.totalWaves && gameState.currentWave % 3 === 0) {
                let miniBossType = 'tank';
                if (gameState.currentLevel < 5) miniBossType = 'fast';
                gameState.enemies.push(new Enemy(miniBossType, false, true));
                const enemyCount = gameState.currentLevel; // spawn some minions
                for (let i = 0; i < enemyCount; i++) {
                     setTimeout(() => { if(gameState.gameRunning) gameState.enemies.push(new Enemy(gameState.levelEnemyType)); }, i * 500);
                }
                return;
            }

            // Normal Wave
            const enemyCount = gameState.currentWave * 3 + gameState.currentLevel;
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => { if(gameState.gameRunning) gameState.enemies.push(new Enemy(gameState.levelEnemyType)); }, i * 400);
            }
        }
        
        function update() {
            if (!gameState.gameRunning || gameState.isPaused) return;

            gameState.player?.update();
            gameState.towers.forEach(t => t.update());
            gameState.enemies.forEach(e => e.update());
            gameState.projectiles.forEach(p => p.update());
            gameState.effects.forEach(e => e.update());
            gameState.coinsOnGround.forEach(c => c.update());
            
            gameState.enemies = gameState.enemies.filter(e => {
                if (e.health <= 0) {
                    let coinValue = ENEMY_TYPES[e.type].coins * (1 + gameState.currentLevel * 0.1);
                    if (e.isBoss) coinValue *= 3;
                    if (e.isMiniBoss) coinValue *= 1.5;
                    gameState.coinsOnGround.push(new Coin(e.x, e.y, Math.floor(coinValue)));
                    return false;
                }
                return true;
            });
            gameState.towers = gameState.towers.filter(t => t.health > 0);
            gameState.projectiles = gameState.projectiles.filter(p => p.x > -50);
            gameState.effects = gameState.effects.filter(e => e.duration > 0);
            gameState.coinsOnGround = gameState.coinsOnGround.filter(c => c.life > 0);
            
            if (ui.startWaveButton.style.display === 'none' && gameState.enemies.length === 0 && gameState.waveCountdown < 0) {
                 if (gameState.currentWave >= gameState.totalWaves) {
                    levelComplete();
                 } else {
                    gameState.waveCountdown = 180; // 3 seconds at 60fps
                 }
            }

            if (gameState.waveCountdown > 0) {
                gameState.waveCountdown--;
                if (gameState.waveCountdown === 0) {
                    spawnWave();
                    gameState.waveCountdown = -1;
                }
            }
            
            updateUI();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#111827';
            ctx.fillRect(0,0,canvas.width, canvas.height);

            ctx.strokeStyle = '#374151';
            ctx.lineWidth = TILE_SIZE;
            ctx.beginPath();
            if (gameState.path.length > 0) {
                ctx.moveTo(gameState.path[0].x, gameState.path[0].y);
                for (let i = 1; i < gameState.path.length; i++) ctx.lineTo(gameState.path[i].x, gameState.path[i].y);
            }
            ctx.stroke();

            gameState.coinsOnGround.forEach(c => c.draw());
            gameState.towers.forEach(t => t.draw());
            gameState.player?.draw();
            gameState.enemies.forEach(e => e.draw());
            gameState.projectiles.forEach(p => p.draw());
            gameState.effects.forEach(e => e.draw());

            if (gameState.selectedTowerType) {
                const gridX = Math.floor(gameState.mouse.x / TILE_SIZE), gridY = Math.floor(gameState.mouse.y / TILE_SIZE);
                if(gridX >= 0 && gridX < GRID_WIDTH && gridY >= 0 && gridY < GRID_HEIGHT) {
                    const canPlace = gameState.grid[gridY][gridX] === 0;
                    const centerX = gridX * TILE_SIZE + TILE_SIZE / 2, centerY = gridY * TILE_SIZE + TILE_SIZE / 2;
                    const towerConf = TOWER_TYPES[gameState.selectedTowerType];
                    const range = towerConf.range * (1 + getPerkEffect('towerRange'));
                    ctx.fillStyle = canPlace ? 'rgba(255, 255, 255, 0.1)' : 'rgba(255, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, range, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = canPlace ? towerConf.color : '#ef4444';
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, TILE_SIZE / 2 - 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            }

            if (gameState.waveCountdown > 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = 'bold 72px Orbitron';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(Math.ceil(gameState.waveCountdown / 60), canvas.width / 2, canvas.height / 2);
            }
            
            if (gameState.isPaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 72px Orbitron';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("PAUSED", canvas.width / 2, canvas.height / 2);
            }
            requestAnimationFrame(draw);
        }

        // --- UI & STATE MANAGEMENT ---
        function updateUI() {
            ui.fortressHealth.textContent = `${Math.ceil(gameState.fortressHealth)}/${gameState.maxFortressHealth}`;
            ui.waveInfo.textContent = `Wave: ${gameState.currentWave}/${gameState.totalWaves}`;
            ui.towerCount.textContent = `Towers: ${gameState.towers.length}/${gameState.maxTowers}`;
            ui.coins.textContent = gameState.coins;
            ui.playerLevel.textContent = gameState.playerData.level;
            const xpForNextLevel = 100 * Math.pow(1.2, gameState.playerData.level - 1);
            ui.xpText.textContent = `${Math.floor(gameState.playerData.xp)} / ${Math.floor(xpForNextLevel)} XP`;
            ui.xpBar.style.width = `${(gameState.playerData.xp / xpForNextLevel) * 100}%`;
            ui.gems.textContent = gameState.playerData.gems;
            if(gameState.player) {
                ui.playerHealthBar.style.width = `${(gameState.player.health / gameState.player.maxHealth) * 100}%`;
                ui.playerHealthText.textContent = `${Math.ceil(gameState.player.health)} / ${Math.ceil(gameState.player.maxHealth)}`;
            }
            updateTowerBarAffordability();
        }
        
        function updateTowerBarAffordability() {
            const towerLimitReached = gameState.towers.length >= gameState.maxTowers;
            const buttons = ui.towerBuildBar.querySelectorAll('.tower-button');
            buttons.forEach(button => {
                const cost = TOWER_TYPES[button.dataset.type].cost;
                button.disabled = (gameState.coins < cost) || towerLimitReached;
            });
        }
        
        function populateTowerBar() {
            ui.towerBuildBar.innerHTML = '';
            for (const type in TOWER_TYPES) {
                const config = TOWER_TYPES[type];
                const button = document.createElement('button');
                button.className = 'tower-button w-16 h-16 rounded-lg border-2 border-gray-600 flex flex-col items-center justify-center hover:bg-gray-700 transition relative has-tooltip';
                button.style.backgroundColor = config.color + '40';
                button.dataset.type = type;
                button.innerHTML = `
                    <div class="text-xl font-bold">${config.name.substring(0,2)}</div>
                    <div class="text-yellow-400 text-sm">${config.cost}</div>
                    <div class="tooltip absolute bottom-full mb-2 w-48 bg-gray-800 text-white text-xs rounded py-1 px-2 pointer-events-none shadow-lg z-10">
                        <p class="font-bold text-base">${config.name} - ${config.cost}c</p>
                        <p>${config.description}</p>
                        <p>${config.damage ? `Dmg: ${config.damage}` : `Heal: ${config.healAmount}`}, Rng: ${config.range}, HP: ${config.health}</p>
                    </div>`;
                button.onclick = () => {
                    if (gameState.coins >= config.cost && gameState.towers.length < gameState.maxTowers) {
                        gameState.selectedTowerType = type;
                        gameState.selectedTower = null;
                        showTowerBuildUI();
                    }
                };
                ui.towerBuildBar.appendChild(button);
            }
        }
        
        function showTowerUpgradeUI(tower) {
            ui.towerBuildBar.classList.add('hidden');
            ui.towerUpgradeBar.classList.remove('hidden');
            let statsText;
            if(tower.type === 'healer') {
                statsText = `Heal: ${tower.config.healAmount.toFixed(1)} | Rng: ${tower.getRange().toFixed(0)} | HP: ${Math.ceil(tower.health)}/${tower.maxHealth.toFixed(0)}`;
            } else {
                statsText = `Dmg: ${tower.getDamage().toFixed(1)} | Rng: ${tower.getRange().toFixed(0)} | HP: ${Math.ceil(tower.health)}/${tower.maxHealth.toFixed(0)}`;
            }
            ui.towerUpgradeBar.innerHTML = `
                <div class="flex items-center space-x-3">
                    <div class="w-12 h-12 rounded-lg flex items-center justify-center text-xl font-bold" style="background-color: ${tower.config.color};">
                       ${tower.config.name.substring(0,2)}
                    </div>
                    <div>
                        <p class="font-bold">${tower.config.name} - Lvl ${tower.level}</p>
                        <p class="text-xs">${statsText}</p>
                    </div>
                </div>
                <button id="upgrade-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                    Upgrade (${tower.getUpgradeCost()})
                </button>`;
            const upgradeButton = document.getElementById('upgrade-button');
            upgradeButton.onclick = () => tower.upgrade();
            if (gameState.coins < tower.getUpgradeCost()) {
                upgradeButton.disabled = true;
                upgradeButton.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        function showTowerBuildUI() {
            ui.towerBuildBar.classList.remove('hidden');
            ui.towerUpgradeBar.classList.add('hidden');
        }

        function showModal(modal) {
            Object.values(ui.modals).forEach(m => m.classList.remove('flex'));
            modal.classList.add('flex');
        }

        function hideModals() {
            Object.values(ui.modals).forEach(m => m.classList.remove('flex'));
        }

        function setupLevel(weaponType) {
            gameState.gameRunning = false;
            gameState.isPaused = false;
            ui.pauseIcon.classList.remove('hidden');
            ui.playIcon.classList.add('hidden');
            gameState.fortressHealth = gameState.maxFortressHealth;
            const startingCoinsPerk = getPerkEffect('startingCoins');
            gameState.coins = (350 + (gameState.currentLevel * 10)) + startingCoinsPerk;
            gameState.currentWave = 0;
            gameState.totalWaves = Math.min(10, 5 + Math.floor(gameState.currentLevel / 2));
            gameState.maxTowers = Math.min(10, 6 + Math.floor(gameState.currentLevel / 2));
            gameState.levelEnemyType = 'basic';
            gameState.towers = [];
            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.effects = [];
            gameState.coinsOnGround = [];
            gameState.selectedTower = null;
            gameState.selectedTowerType = null;
            gameState.player = new Player(TILE_SIZE * 2, canvas.height / 2, weaponType);
            showTowerBuildUI();
            
            generatePath();
            updateUI();
            
            ui.startWaveButton.textContent = 'READY';
            ui.startWaveButton.style.display = 'block';
        }
        
        function levelComplete() {
            gameState.gameRunning = false;
            
            const timeTaken = (Date.now() - gameState.levelStartTime) / 1000;
            const baseXP = 100 + gameState.currentLevel * 20;
            const timeBonus = Math.max(0, 120 - Math.floor(timeTaken));
            const towerBonus = gameState.towers.length * 5;
            const totalXP = baseXP + timeBonus + towerBonus;

            document.getElementById('complete-modal-base-xp').textContent = baseXP;
            document.getElementById('complete-modal-time-bonus').textContent = timeBonus;
            document.getElementById('complete-modal-tower-bonus').textContent = towerBonus;
            document.getElementById('complete-modal-total-xp').textContent = totalXP;
            
            let leveledUp = gainXP(totalXP);
            if (leveledUp) {
                ui.levelUpAlert.classList.remove('hidden');
                ui.gemReward.textContent = leveledUp.gemsEarned;
            } else {
                ui.levelUpAlert.classList.add('hidden');
            }
            savePlayerData();
            showModal(ui.modals.levelComplete);
        }

        function gainXP(amount) {
            gameState.playerData.xp += amount;
            let xpForNextLevel = 100 * Math.pow(1.2, gameState.playerData.level - 1);
            let leveledUp = false;
            let gemsEarned = 0;
            while (gameState.playerData.xp >= xpForNextLevel) {
                gameState.playerData.xp -= xpForNextLevel;
                gameState.playerData.level++;
                gameState.playerData.gems++;
                gemsEarned++;
                xpForNextLevel = 100 * Math.pow(1.2, gameState.playerData.level - 1);
                leveledUp = true;
            }
            return leveledUp ? { gemsEarned } : null;
        }

        function levelFailed() {
             gameState.gameRunning = false;
             showModal(ui.modals.levelFailed);
        }

        function savePlayerData() {
            localStorage.setItem('endlessTDPlayer_v2', JSON.stringify(gameState.playerData));
        }

        function loadPlayerData() {
            const savedData = localStorage.getItem('endlessTDPlayer_v2');
            if (savedData) {
                const parsedData = JSON.parse(savedData);
                if (!parsedData.perks) parsedData.perks = {};
                gameState.playerData = parsedData;
            } else {
                gameState.playerData = { level: 1, xp: 0, gems: 0, perks: {} };
            }
        }
        
        // --- PERKS LOGIC ---
        function getPerkLevel(perkId) {
            return gameState.playerData.perks[perkId] || 0;
        }
        
        function getPerkEffect(perkId) {
            const level = getPerkLevel(perkId);
            if(level === 0) return 0;
            return PERKS_CONFIG[perkId].effect * level;
        }

        function applyPerkToExistingTowers() {
            const healthPerkEffect = getPerkEffect('towerHealth');
            gameState.towers.forEach(tower => {
                const oldMaxHealth = tower.maxHealth;
                const newMaxHealth = tower.config.health * (1 + healthPerkEffect);
                const healthIncrease = newMaxHealth - oldMaxHealth;
                tower.maxHealth = newMaxHealth;
                tower.health += healthIncrease;
            });
        }
        
        function buyPerk(perkId) {
            const perk = PERKS_CONFIG[perkId];
            const level = getPerkLevel(perkId);
            const cost = perk.cost + (level * perk.costIncrease);
            if(gameState.playerData.gems >= cost && level < perk.maxLevel) {
                gameState.playerData.gems -= cost;
                gameState.playerData.perks[perkId] = level + 1;
                
                if (perkId === 'towerHealth') applyPerkToExistingTowers();
                if (gameState.player) {
                    if (perkId === 'playerHealth') {
                        const oldMax = gameState.player.maxHealth;
                        gameState.player.maxHealth = 100 + getPerkEffect('playerHealth');
                        gameState.player.health += gameState.player.maxHealth - oldMax;
                    }
                    if (perkId === 'pickupRange') {
                        gameState.player.pickupRange = 80 + getPerkEffect('pickupRange');
                    }
                }
                
                savePlayerData();
                populatePerksModal();
                updateUI();
            }
        }
        
        function populatePerksModal() {
            const { level } = gameState.playerData;
            ui.playerPerksList.innerHTML = '';
            ui.globalPerksList.innerHTML = '';
            ui.towerPerksList.innerHTML = '';
            ui.globalPerksLock.style.display = level >= PERKS_CONFIG.towerDamage.unlockLevel ? 'none' : 'inline';
            ui.towerPerksLock.style.display = level >= PERKS_CONFIG.turretStartLevel.unlockLevel ? 'none' : 'inline';

            for (const id in PERKS_CONFIG) {
                const perk = PERKS_CONFIG[id];
                const currentLevel = getPerkLevel(id);
                const cost = perk.cost + (currentLevel * perk.costIncrease);
                
                const perkEl = document.createElement('div');
                perkEl.className = `bg-gray-700/50 p-3 rounded-lg flex justify-between items-center ${level < perk.unlockLevel ? 'perk-locked' : ''}`;
                perkEl.innerHTML = `
                    <div>
                        <p class="font-bold">${perk.name} <span class="text-sm text-gray-400">(Lvl ${currentLevel}/${perk.maxLevel})</span></p>
                        <p class="text-xs">Next: +${perk.effect.toFixed(2)}</p>
                    </div>
                    <button data-perk-id="${id}" class="perk-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-1 px-3 rounded">
                        Buy (${cost} G)
                    </button>
                `;
                const buyButton = perkEl.querySelector('button');
                if (currentLevel >= perk.maxLevel) {
                    buyButton.textContent = 'Max';
                    buyButton.disabled = true;
                } else if (gameState.playerData.gems < cost || level < perk.unlockLevel) {
                    buyButton.disabled = true;
                }
                
                if (perk.type === 'player') ui.playerPerksList.appendChild(perkEl);
                else if (perk.type === 'global') ui.globalPerksList.appendChild(perkEl);
                else ui.towerPerksList.appendChild(perkEl);
            }
        }

        function populateWeaponSelection() {
            const grid = document.getElementById('weapon-selection-grid');
            grid.innerHTML = '';
            let selectedWeapon = null;
            for (const type in PLAYER_WEAPONS) {
                const weapon = PLAYER_WEAPONS[type];
                const card = document.createElement('div');
                card.className = 'weapon-card bg-gray-700 p-4 rounded-lg border-2 border-gray-600 cursor-pointer';
                card.dataset.weapon = type;
                card.innerHTML = `
                    <h3 class="text-xl font-orbitron text-blue-400 mb-2">${weapon.name}</h3>
                    <p class="text-sm text-gray-300 mb-3">${weapon.description}</p>
                    <div class="text-xs text-left space-y-1">
                        <p><strong>Damage:</strong> ${weapon.damage}</p>
                        <p><strong>Fire Rate:</strong> ${weapon.fireRate}</p>
                        <p><strong>Range:</strong> ${weapon.range}</p>
                    </div>
                `;
                card.addEventListener('click', () => {
                    grid.querySelectorAll('.weapon-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    selectedWeapon = type;
                    document.getElementById('confirm-weapon-button').disabled = false;
                });
                grid.appendChild(card);
            }
             document.getElementById('confirm-weapon-button').onclick = () => {
                 if(selectedWeapon) {
                     hideModals();
                     setupLevel(selectedWeapon);
                     showModal(ui.modals.levelStart);
                 }
            };
        }

        // --- EVENT LISTENERS ---
        ui.startWaveButton.onclick = () => {
            spawnWave();
            ui.startWaveButton.style.display = 'none';
        };

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            gameState.mouse.x = e.clientX - rect.left;
            gameState.mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('click', () => {
            if (gameState.isPaused) return;
            const gridX = Math.floor(gameState.mouse.x / TILE_SIZE);
            const gridY = Math.floor(gameState.mouse.y / TILE_SIZE);

            if (gameState.selectedTowerType) {
                if (gridY < GRID_HEIGHT && gridX < GRID_WIDTH && gameState.grid[gridY][gridX] === 0) {
                     if (gameState.towers.length < gameState.maxTowers) {
                        const cost = TOWER_TYPES[gameState.selectedTowerType].cost;
                         if (gameState.coins >= cost) {
                            gameState.coins -= cost;
                            gameState.towers.push(new Tower(gridX * TILE_SIZE + TILE_SIZE / 2, gridY * TILE_SIZE + TILE_SIZE / 2, gameState.selectedTowerType));
                            gameState.grid[gridY][gridX] = 2;
                            updateUI();
                         }
                     }
                }
                gameState.selectedTowerType = null;
            } else {
                gameState.selectedTower = null;
                 for(const tower of gameState.towers) {
                    if (Math.hypot(gameState.mouse.x - tower.x, gameState.mouse.y - tower.y) < TILE_SIZE/2) {
                        gameState.selectedTower = tower;
                        break;
                    }
                 }
                 if(gameState.selectedTower) showTowerUpgradeUI(gameState.selectedTower);
                 else showTowerBuildUI();
            }
        });
        
        document.getElementById('start-level-button').onclick = () => {
            hideModals();
            gameState.gameRunning = true;
            gameState.levelStartTime = Date.now();
        };

        document.getElementById('next-level-button').onclick = () => {
            gameState.currentLevel++;
            hideModals();
            populateWeaponSelection();
            showModal(ui.modals.weaponSelect);
        };
        
        document.getElementById('retry-level-button').onclick = () => {
            hideModals();
            populateWeaponSelection();
            showModal(ui.modals.weaponSelect);
        };
        
        const perkButtonClickHandler = (e) => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.perkId) {
                buyPerk(e.target.dataset.perkId);
            }
        };

        ui.playerPerksList.addEventListener('click', perkButtonClickHandler);
        ui.globalPerksList.addEventListener('click', perkButtonClickHandler);
        ui.towerPerksList.addEventListener('click', perkButtonClickHandler);
        
        ui.pauseButton.addEventListener('click', () => {
            gameState.isPaused = !gameState.isPaused;
            ui.pauseIcon.classList.toggle('hidden');
            ui.playIcon.classList.toggle('hidden');
        });
        
        document.getElementById('perks-button').addEventListener('click', () => {
            populatePerksModal();
            showModal(ui.modals.perks);
        });

        document.getElementById('close-perks-button').onclick = hideModals;

        window.addEventListener('keydown', (e) => gameState.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', (e) => gameState.keys[e.key.toLowerCase()] = false);

        function onResize() {
            const wrapper = document.getElementById('game-wrapper');
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            GRID_WIDTH = Math.floor(canvas.width / TILE_SIZE);
            GRID_HEIGHT = Math.floor(canvas.height / TILE_SIZE);
            if(gameState.path.length === 0) generatePath();
        }

        // --- INITIALIZATION ---
        function init() {
            loadPlayerData();
            onResize();
            window.addEventListener('resize', onResize);
            
            populateTowerBar();
            populateWeaponSelection();
            
            document.getElementById('start-modal-level').textContent = gameState.currentLevel;
            document.getElementById('start-modal-coins').textContent = (350 + (gameState.currentLevel * 10)) + getPerkEffect('startingCoins');
            const enemyTypesHtml = Object.values(ENEMY_TYPES).map(e => `<div class="flex items-center gap-2"><div class="w-4 h-4 rounded-full" style="background-color:${e.color}"></div><span>${e.name}</span></div>`).join('');
            document.getElementById('start-modal-enemies').innerHTML = enemyTypesHtml;
            showModal(ui.modals.weaponSelect);
            
            requestAnimationFrame(draw);
            setInterval(update, 1000 / 60);
        }

        init();
    </script>
</body>
</html>

